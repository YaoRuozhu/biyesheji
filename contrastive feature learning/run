import dataset
import simclr
import torch.nn as nn    #神经网络API
import torch.optim as optim
from argparse import Namespace
import matplotlib.pyplot as plt
import torch.utils.data as Data
import fgsm

batch_size = 2
learning_rate = 3e-3
epoches = 2
hparams = Namespace(
    lr=0.000630957344480193,
    epochs=10,
    batch_size=batch_size,
    train_size=1000,
    validation_size=200
)

# 载入训练集与测试集数据
train_data = dataset.train_mini_train()
#train_ds = simclr.PretrainingDatasetWrapper(train_data, debug=False)
train_loader = Data.DataLoader(dataset=train_data, batch_size=batch_size, shuffle=True)
test_data = dataset.test_mini_test()
#test_ds = simclr.PretrainingDatasetWrapper(test_data, debug=False)
test_loader = Data.DataLoader(dataset=test_data, batch_size=batch_size, shuffle=True)

# 载入网络结构
model = simclr.ImageEmbedding()


def forward(self, X):
    return self.model(X)

# 声明损失函数及优化器
loss_fn = simclr.ContrastiveLoss(hparams.batch_size)
optim = optim.Adam(params=model.parameters(), lr=learning_rate)

# 输出网络结构信息
# printNetInfo(net)

train_accs = []
test_accs = []
losses = []
for epoch in range(epoches):
    model.train()  # 训练
    for step, data in enumerate(train_loader, start=0):
        images, labels = data[0]
        X = images
        data_grad = X.grad.data
        Y = fgsm.fgsm_attack(X, 0.1, data_grad)
        optim.zero_grad()  # 优化器梯度清0
        embX, projectionX = model(X)
        embY, projectionY = model(Y)
        loss = loss_fn(projectionX.view(1,-1), projectionY.view(1,-1))  # 计算损失函数
        loss.backward()  # 反向传播求梯度
        optim.step()  # 优化器进一步优化

        rate = (step + 1) / len(train_loader)
        a = "*" * int(rate * 50)
        b = "." * int((1 - rate) * 50)
        print("\repoch:%s train loss:%3.0f%%:%.4f" % (epoch, int(rate * 100), loss), end="  ")
    losses.append(loss)

    model.eval()  # 测试
    train_acc = dataset.eval_on_dataloader("train", train_loader, train_data.__len__())
    train_accs.append(train_acc)

    test_acc = dataset.eval_on_dataloader("test", test_loader, test_data.__len__())
    test_accs.append(test_acc)

    print("train_acc:", train_acc, " test_acc:", test_acc)

    # 模型训练损失可视化
    #data.plot_loss_result(losses)
    #plt.show()

    # 训练集与测试集精度可视化
    dataset.plot_train_and_test_result(train_accs, test_accs)
    plt.show()
