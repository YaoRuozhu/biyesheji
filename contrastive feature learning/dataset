import torch
from sklearn import datasets  #加载数据集用
from sklearn import model_selection   #数据集切分
import matplotlib.pyplot as plt  #数据可视化
import numpy as np     #数字格式转换
import torch.nn as nn

class train_mini_train():
    '''构建训练集'''

    def __init__(self):
        # 加载手写数字数据集digits，有标签，class为1~10
        self.X, self.y = \
            datasets.load_digits(return_X_y=True)

        print('样本总数：', len(self.X))
        print('样本特征维度：', len(self.X[0]))

        # 数据集切分
        self.X_train, self.X_test, self.y_train, self.y_test = \
            model_selection.train_test_split(self.X, self.y, random_state=0)

        print('构建训练集样本总数：', len(self.y_train))

    def __len__(self):
        # 返回训练集数据量
        return len(self.y_train)

    def __getitem__(self, index):
        #self.y_train = self.y_train.long()
        return torch.tensor(self.X_train[index].reshape(1, 8, 8), dtype=torch.float32), self.y_train[index]


class test_mini_test():
    '''构建测试集'''

    def __init__(self):
        self.X, self.y = datasets.load_digits(return_X_y=True)
        self.X_train, self.X_test, self.y_train, self.y_test = \
            model_selection.train_test_split(self.X, self.y, random_state=0)

        print('构建测试集样本总数：', len(self.y_test))

    def __getitem__(self, index):
        #self.y_test = self.y_test.long()
        return torch.tensor(self.X_test[index].reshape(1, 8, 8), dtype=torch.float32), self.y_test[index]

    def __len__(self):
        return len(self.y_test)


def plot_train_and_test_result(train_accs,test_accs):
    epoches = np.arange(1,len(train_accs)+1,dtype=np.int32)
    plt.plot(epoches,train_accs,label='train accuracy')
    plt.plot(epoches,test_accs, label='test accuracy')
    plt.xlabel('epoches')
    plt.ylabel('accuracy')
    plt.legend()


def plot_loss_result(losses):
    epoches = np.arange(1, len(losses) + 1, dtype=np.int32)
    plt.plot(epoches, losses, label='loss')
    plt.xlabel('epoches')
    plt.ylabel('loss')
    plt.legend()


def printNetInfo(net):
    '''输出神经网络结构的信息'''
    for name,parameters in net.named_parameters():
        print(name,":",parameters.size())

def eval_on_dataloader(model,loader,len):
    acc = 0.0
    with torch.no_grad():
        for data in loader:
            images, labels = data
            outputs = model(images)

            # torch.max返回两个数值，一个[0]是最大值，一个[1]是最大值的下标
            predict_y = torch.max(outputs, dim=1)[1]

            acc += (predict_y == labels.long()).sum().item()
        accurate = acc / len
        return accurate


def TestAccuracy(model, testLoader):
    softmax = nn.Softmax(dim=1)
    acc = 0
    with torch.no_grad():
        for data, target in testLoader:
            data = data
            target = target.long()
            output = model(data)
            predict = torch.argmax(softmax(output), dim=1)
            acc += (predict == target).sum().item()
        return acc/len(testLoader.dataset)
