import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import matplotlib.pyplot as plt  #数据可视化
import numpy as np     #数字格式转换
import torch
import torch.utils.data as Data
import dataset
import cnn


plot_train_and_test_result = dataset.plot_train_and_test_result
plot_loss_result = dataset.plot_loss_result
printNetInfo = dataset.printNetInfo


def eval_on_dataloader(name, loader, len):
    acc = 0.0
    with torch.no_grad():
        for data in loader:
            images, labels = data
            outputs = model(images)

            # torch.max返回两个数值，一个[0]是最大值，一个[1]是最大值的下标
            predict_y = torch.max(outputs, dim=1)[1]

            acc += (predict_y == labels.long()).sum().item()
        accurate = acc / len
        return accurate

batch_size = 3
learning_rate = 3e-3
epoches = 2

# 载入训练集与测试集数据
train_data = dataset.train_mini_train()
test_data = dataset.test_mini_test()
train_loader = Data.DataLoader(dataset=train_data, batch_size=batch_size, shuffle=True)
test_loader = Data.DataLoader(dataset=test_data, batch_size=batch_size, shuffle=True)
#test_loader = torch.utils.data.DataLoader(dataset=train_data, batch_size=1, shuffle=True)


# 载入网络结构
model = cnn.SimpleNet(64)

# 声明损失函数及优化器
loss_fn = nn.CrossEntropyLoss()
optim = optim.Adam(params=model.parameters(), lr=learning_rate)

# 输出网络结构信息
# printNetInfo(net)

train_accs = []
test_accs = []
losses = []
for epoch in range(epoches):
    model.train()  # 训练
    for step, data in enumerate(train_loader, start=0):
        images, labels = data
        #print(images.shape)
        #print(labels)
        optim.zero_grad()  # 优化器梯度清0
        logits = model(images)  # 输入images 经过网络推断输出结果

        loss = loss_fn(logits, labels.long())  # 计算损失函数
        loss.backward()  # 反向传播求梯度
        optim.step()  # 优化器进一步优化

        rate = (step + 1) / len(train_loader)
        a = "*" * int(rate * 50)
        b = "." * int((1 - rate) * 50)
        print("\repoch:%s train loss:%3.0f%%:%.4f" % (epoch, int(rate * 100), loss), end="  ")
    losses.append(loss)

    model.eval()  # 测试
    train_acc = eval_on_dataloader("train", train_loader, train_data.__len__())
    train_accs.append(train_acc)

    test_acc = eval_on_dataloader("test", test_loader, test_data.__len__())
    test_accs.append(test_acc)

    print("train_acc:", train_acc, " test_acc:", test_acc)

    # 模型训练损失可视化
    #plot_loss_result(losses)
    #plt.show()

    # 训练集与测试集精度可视化
    plot_train_and_test_result(train_accs, test_accs)
    
    # plt.show()

#保存模型成文件后再训练不会影响原有模型
# torch.save(model.state_dict(), './params0.pth')
torch.save(model,"model-0.pt")
