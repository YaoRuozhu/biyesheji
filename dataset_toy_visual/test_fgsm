import tensorflow as tf
import keras as keras
import keras.layers as layers
from keras.models import Sequential
import sklearn.datasets as datasets
from keras.layers import Dense
from sklearn.datasets import load_iris
from sklearn import tree
import numpy as np
from matplotlib.colors import ListedColormap
from keras import backend as K
import draw_model
import data
import robustness_calculator
import draw_robustness
import time


time_total = 0
time_orig_total = 0

count_correct_close_list = []
count_wrong_list = []
rand_list = []
model_robustness_list = []
iter_no_list = []
test_accuracy_list = []
model_orig_robustness_list = []
model_flat_list = []
model_flat_orig_list = []


data_orig = data.data_orig
count_feature = data.count_feature
count_data = data.count_data
count_label = data.count_label
count_train = int(0.8*count_data)
count_test = int(0.2*count_data)
#history = draw_model.history

data_attack = np.load('data_fgsm.npy')
data_orig = data.data_orig
radius = data.radius
x_train_orig = data_orig[:-count_test, 0:count_feature]
x_train = x_train_orig
x_test = data_orig[-count_test:, 0:count_feature]
y_train_orig = data_orig[:-count_test, count_feature]
y_train = y_train_orig
y_test_orig = data_orig[-count_test:, count_feature]
y_test = keras.utils.to_categorical(y_test_orig, num_classes=count_label)
data_train_orig = np.hstack((x_train_orig, y_train_orig.reshape(count_train, 1), np.arange(1, count_train+1, 1).reshape(count_train, 1), data.radius*np.ones((count_train, 1)), data.bagsize*np.ones((count_train, 1))))
y_orig = keras.utils.to_categorical(y_train_orig, num_classes=count_label)
count_column = data_train_orig[0, :].size



model = Sequential()
model.add(Dense(15, activation='relu', input_dim=count_feature))
model.add(Dense(15, activation='relu'))
model.add(Dense(15, activation='relu'))
model.add(Dense(15, activation='relu'))
model.add(Dense(15, activation='relu'))
model.add(Dense(count_label, activation='softmax'))
model.compile(loss='categorical_crossentropy',
              optimizer='sgd',
              metrics=['accuracy'])
model_orig = Sequential()
model_orig.add(Dense(15, activation='relu', input_dim=count_feature))
model_orig.add(Dense(15, activation='relu'))
model_orig.add(Dense(15, activation='relu'))
model_orig.add(Dense(15, activation='relu'))
model_orig.add(Dense(15, activation='relu'))
model_orig.add(Dense(count_label, activation='softmax'))
model_orig.compile(loss='categorical_crossentropy',
              optimizer='sgd',
              metrics=['accuracy'])

model.load_weights('my_model1_weights.h5')
model_orig.load_weights('my_model1_weights.h5')

data_attack = np.load('data_fgsm.npy')
x_attack = data_attack[:, 0:count_feature]
y_attack = data_attack[:, count_feature]

for iter_no in range(11):

    time_start = time.time()
    # 找到分类错误点

    x_train = np.vstack([x_train_orig, x_attack])
    y_train = np.append(y_train_orig, y_attack)

    # if (count_wrong+count_correct_close) / count_data < 0.02:
    # break

    np.random.seed(iter_no+100)
    np.random.shuffle(x_train)
    np.random.seed(iter_no + 100)
    np.random.shuffle(y_train)

    y_train = keras.utils.to_categorical(y_train, num_classes=count_label)
    model.fit(x_train, y_train, epochs=8, batch_size=32, validation_data=(x_test, y_test))
    time_end = time.time()
    time1 = time_end - time_start
    time_total = time_total + time1
    pred_test = model.predict(x_train_orig)
    pred_test = np.argmax(pred_test, axis=1).reshape(count_train, 1)
    correct_test = np.equal(y_train_orig.reshape(count_train, 1), pred_test) + 0
    test_accuracy = correct_test.sum().astype(np.int32) / count_train
    print('accu' + str(test_accuracy))

    iter_no_list.append(iter_no)
    test_accuracy_list.append(test_accuracy)

    draw_model.draw(model, iter_no, 'model')
    model_robustness = robustness_calculator.robustness_calculator(model)
    print(str(iter_no) + 'model:' + str(model_robustness))
    model_robustness_list.append(model_robustness)

    print(str(iter_no) + 'time:' + str(time_total))
    print(iter_no)
np.save('randomrobust.npy', model_robustness_list)
np.save('origrobust.npy', model_orig_robustness_list)
draw_robustness.draw_robustness_accuracy(iter_no_list, model_orig_robustness_list, model_robustness_list)
